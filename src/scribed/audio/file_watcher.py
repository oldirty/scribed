"""File watcher for batch audio transcription."""

import asyncio
import logging
from pathlib import Path
from typing import TYPE_CHECKING, Set, Any
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent, FileSystemEvent

if TYPE_CHECKING:
    from ..config import Config
    from ..daemon import ScribedDaemon

logger = logging.getLogger(__name__)


class AudioFileHandler(FileSystemEventHandler):
    """Handler for audio file events."""

    def __init__(self, file_watcher: "FileWatcher") -> None:
        """Initialize handler."""
        super().__init__()
        self.file_watcher = file_watcher

    def on_created(self, event: FileSystemEvent) -> None:
        """Handle file creation events."""
        if event.is_directory:
            return

        file_path = Path(str(event.src_path))  # Ensure str conversion
        if file_path.suffix.lower() in self.file_watcher.supported_formats:
            logger.info(f"New audio file detected: {file_path}")
            asyncio.create_task(self.file_watcher.process_file(file_path))


class FileWatcher:
    """File system watcher for batch audio processing."""

    def __init__(self, config: "Config", daemon: "ScribedDaemon") -> None:
        """Initialize file watcher."""
        self.config = config
        self.daemon = daemon
        self.supported_formats = set(config.file_watcher.supported_formats)
        self.watch_directory = Path(config.file_watcher.watch_directory)
        self.output_directory = Path(config.file_watcher.output_directory)

        # Ensure directories exist
        self.watch_directory.mkdir(parents=True, exist_ok=True)
        self.output_directory.mkdir(parents=True, exist_ok=True)

        self.observer = Observer()  # type: ignore
        self.handler = AudioFileHandler(self)
        self._running = False
        self._processed_files: Set[Path] = set()

    async def start(self) -> None:
        """Start watching for files."""
        if self._running:
            logger.warning("File watcher is already running")
            return

        logger.info(f"Starting file watcher on {self.watch_directory}")
        logger.info(f"Supported formats: {', '.join(self.supported_formats)}")

        self.observer.schedule(self.handler, str(self.watch_directory), recursive=False)  # type: ignore
        self.observer.start()  # type: ignore
        self._running = True

        # Process any existing files
        await self._process_existing_files()

    async def stop(self) -> None:
        """Stop watching for files."""
        if not self._running:
            return

        logger.info("Stopping file watcher...")
        self.observer.stop()  # type: ignore
        self.observer.join()  # type: ignore
        self._running = False

    async def _process_existing_files(self) -> None:
        """Process any audio files that already exist in the watch directory."""
        logger.info("Checking for existing audio files...")

        for file_path in self.watch_directory.iterdir():
            if (
                file_path.is_file()
                and file_path.suffix.lower() in self.supported_formats
                and file_path not in self._processed_files
            ):
                logger.info(f"Processing existing file: {file_path}")
                await self.process_file(file_path)

    async def process_file(self, file_path: Path) -> None:
        """Process a single audio file."""
        if file_path in self._processed_files:
            logger.debug(f"File already processed: {file_path}")
            return

        try:
            logger.info(f"Processing audio file: {file_path}")
            self._processed_files.add(file_path)

            # Generate output file path
            output_file = self.output_directory / f"{file_path.stem}.txt"

            # Try to get transcription service from daemon
            transcription_service = getattr(self.daemon, "transcription_service", None)

            if transcription_service and transcription_service.is_available():
                # Use actual transcription service
                logger.info(f"Transcribing with {transcription_service.provider}")
                result = await transcription_service.transcribe_file(file_path)

                if result.status.value == "completed":
                    # Create transcript content with metadata
                    content_lines = [
                        f"# Transcription of {file_path.name}",
                        f"# Generated by Scribed using {transcription_service.provider}",
                        (
                            f"# Processing time: {result.processing_time:.2f}s"
                            if result.processing_time
                            else ""
                        ),
                        f"# Language: {result.language}" if result.language else "",
                        "",
                        result.text,
                    ]

                    # Add segment information if available
                    if result.segments:
                        content_lines.extend(["", "## Segments", ""])
                        for i, segment in enumerate(result.segments, 1):
                            start_time = (
                                f"{segment.start_time:.2f}s"
                                if segment.start_time
                                else "N/A"
                            )
                            end_time = (
                                f"{segment.end_time:.2f}s"
                                if segment.end_time
                                else "N/A"
                            )
                            content_lines.append(
                                f"{i}. [{start_time} - {end_time}] {segment.text}"
                            )

                    transcript_content = "\n".join(content_lines)

                else:
                    # Transcription failed
                    transcript_content = f"# Transcription Failed\n\nError: {result.error}\nFile: {file_path.name}"
                    logger.error(
                        f"Transcription failed for {file_path}: {result.error}"
                    )
            else:
                # Fallback to placeholder transcription
                logger.warning(
                    "No transcription service available, creating placeholder"
                )
                transcript_content = (
                    f"[Transcription placeholder for {file_path.name}]\n"
                )
                transcript_content += f"File: {file_path}\n"
                transcript_content += f"Format: {file_path.suffix}\n"
                transcript_content += f"Size: {file_path.stat().st_size} bytes\n"
                transcript_content += "\nActual transcription will be available when transcription engines are properly configured."

            # Write transcription to output file
            with open(output_file, "w", encoding="utf-8") as f:
                f.write(transcript_content)

            logger.info(f"Transcription saved to: {output_file}")

        except Exception as e:
            logger.error(f"Error processing file {file_path}: {e}")
            # Remove from processed set so it can be retried
            self._processed_files.discard(file_path)
